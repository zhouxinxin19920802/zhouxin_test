**C**

--------------------------------------------------------------------------

**1.C语言头文件**



**「在头文件中定义定义函数和全局变量」这种认知是原则性的错误！**不管是标准头文件，还是自定义头文件，都只能包**含变量和函数的声明，不能包含定义**，否则在多次引入时会引起重复定义错误。

此外，可能还有初学者会问，main.c 只是引入了 my.h，没有引入 my.c，程序在编译时应该找不到函数定义呀，然而当我们亲自去运行程序的时候，却发现运行结果是正确的，这是怎么回事呢？

 C语言多文件编程涉及到很多细节，需要深入理解编译和链接的原理，本节我们仅做演示，不做更多讲解，感兴趣的读者请自行查阅相关资料。



C语言头文件中只能包含变量和函数的声明的，不能包含定义



C语言头文件可以包括:



- 函数声明

- 变量声明

- 宏定义

- 结构体和枚举类型定义

- 其它头文件

- 变量定义

  ​	extern 变量

  ​    static   变量



**2. .c源文件**



.c 源文件如果要用到某个结构体，则需要包含头文件，头文件一般需要在结构体中定义



**3.不带参数的宏定义**

```c
#ifndef MYMACROS_H
#define MYMACROS_H
```

`MYMACROS_H`这个宏没有具体的值，只是起到一个标记的作用，用于在后续的代码中进行条件编译的判断。



**4.反码，补码问题**

前提: 有符号的整数

正数的反码：仍然是原码

正数补码： 仍然是原码

负数的反码: 除符号位外，每位取反

负数补码: 反码+1



**5.二进制表示**

首位是1是负数

首位是0是正数



**6.计算机中数字都是以补码形式存储的**

正数的补码是其本身

负数的补码，先取绝对值，然后各位按位求反，最后加1



**7.补码减法计算原理**

```
补码+补码

十进制为例

15-7

位宽为4

15:0015

-7:1007

-7的反码为9999-7=9992

-7补码为9992+1=9993

0015+9993=10008 舍弃最高位变成了0008
```

*醍醐灌顶的解释*

```
假设现在标准时间为4点整，而有一只表已经到7点了，为了校准时间，可以采用两种方法：一种是将时针退7-4=3格；二是将时针向前拨12-3=9格，这两种方法都可以校准到4点。

摘自《计算机组成原理》p20 第2节

这个例子的意思可以理解为将7变为4，在钟表环境（12进制）下可以表示为7-3和7+9

意即钟表法则中

7-3=7+9

看了这个例子，你大概已经知道能这样做的原因是什么了

根本在于

钟表法则中超过12的数会溢出，重新从0开始计算

准确的说这里的12应该被称为模长，也是补码得以有效的关键，在表示的数值大小被限制时，有了溢出就能将减法变成加法了。

有了这个条件，现在可以总结出一套推论

模长为m时，x-y=x+m-y

你可能会觉得这有什么用？还是得用模长做减法才能得出这个等效加数呀

这就是二进制得天独厚的优势了

m-y可以转变为m-1-y+1

这不是废话吗

别急，在二进制中计算机能表示的数的大小总是以位计算的，也就是说，假如总共有8位，那么模长就是2^8,能表示的是0~2^8-1之间的数。

这时候m-1表示的就是1111 1111，上面的m-1-y+1就是1111 1111 - y +1

而1111 1111-y等效于~y(对y求反)，求一个数的反码在计算机中是很容易实现的，通过触发器互补输出得到

这时x-y=x+~y+1      补码由此实现将减法变为加法

 

总结

补码的意义建立在数值位数确定的情况

补码通过溢出实现将减法转变为加法
```



**8.类型占字节**

char类型只占一个字节

取值范围

有符号

正数 0(111 1111) 1+2+4+8+16+32+64=31+32+64=63+64=127   



**9.char类型最小值为什么是-128**

```
上限容易理解：0111 1111，最高位0表示正数，故为127.

下限不是应该是1111 1111吗？-127. ——对不起，你忘了计算机内部存储的是-127的补码，所以计算机内部表示为：1000 0001（-127的补码）。你是不是发现还可以减1？为1000 0000。注意1000 0000是补码哦。 （1）

-127-1=-128。

我们来算算-128的补码是多少？

先取绝对值128，1000 0000，按位求反：0111 1111 再加1：1000 0000.和（1）的推导正好相符。

所以8位有符号数的取值范围下限是-128.
```



**10.printf函数**

f是format的意思

形式: %|标志||长度||.f||宽度|类型

类型:

| 类型  | 含义                                |
| ----- | ----------------------------------- |
| d     | 有符号10进制整型                    |
| i     | 有符号10进制整型                    |
| u     | 无符号10进制整型                    |
| o     | 无符号8进制整型                     |
| x     | 无符号16进制整型                    |
| X     | 无符号16进制整型                    |
| f     | 单、双精度浮点数(默认保留6位小数)   |
| e / E | 以指数形式输出单、双精度浮点数      |
| g / G | 以最短输出宽度,输出单、双精度浮点数 |
| c     | 字符                                |
| s     | 字符串                              |
| p     | 地址                                |

d：有符号10进制整型  i:有符号10进制整型

宽度：直接数字

长度:

| 长度 | 修饰类型      | 含义               |
| :--- | :------------ | ------------------ |
| hh   | d、i、o、u、x | 输出char           |
| h    | d、i、o、u、x | 输出 short int     |
| l    | d、i、o、u、x | 输出 long int      |
| ll   | d、i、o、u、x | 输出 long long int |



**11.C语言中数组不存储大小信息，无法通过数组获取数组大小**

```
在C语言中，数组本身并不存储自己的大小信息。数组名字仅仅是一个指向数组首元素的指针，因此无法通过数组名字本身来获取数组的大小。数组的大小需要由程序员自行管理。

这就是为什么在使用动态分配内存的情况下，需要通过其他手段来跟踪数组的大小，比如通过一个变量来记录。对于静态分配的数组，虽然编译器会知道数组的大小，但在运行时无法直接通过数组名字来获取大小，同样需要通过其他方式来传递大小信息。
```

**12.C语言单引号是字符，双引号是字符串**



**13.字符串定义数组的时候必须''\0'确保不出现内存问题**



**14.puts作用**

putchar输出单个字符，puts用于输出字符串



**15.String.h中字符串处理函数**

sizeof   字符串长度，包括null

strlen   不包括null

strcat(str1，str2)  字符串合并，删掉第一个字符串str1末尾的null字符，然后合并str2后赋给str1.

strcpy(str1, str2)  相当于把str2赋给了str1.

strcmp(字符数组名1,字符数组名2)

- 字符串比较函数:strcmp
- 功能:按照ASCII码顺序比较两个数组中的字符串,并由函数返回值返回比较结果。

- 字符串1=字符串2,返回值=0;
- 字符串1>字符串2,返回值>0;
- 字符串1<字符串2,返回值<0。



**16.C语言中break能够跳出switch语句**



**17. 16进制的输出问题**

```
%x 是用来格式化输出一个整数为十六进制数的格式说明符，而 0x 是在代码中表示一个十六进制数的前缀。

使用 %x：当你想要以十六进制的格式打印一个整数时，你可以使用 %x。例如，printf("十六进制数为: %x\n", num); 将会打印出变量 num 的十六进制表示。
使用 0x：当你直接在代码中表示一个十六进制数时，你应该在数值前加上 0x 前缀。例如，int num = 0xFF; 将会将十六进制数 FF 赋值给变量 num。
所以，%x 用于格式化输出，而 0x 用于表示一个十六进制数值。
```



**18.16进制中0xff和0xFF一样，不区分大小写，0x和0X一样，也不区分大小写**



**19.指针数组和数组指针区别**

**数组指针:**

- 数组指针是指向数组的指针，它指向数组的首地址。
- 通常声明为`type (*ptr)[size]`的形式，其中`type`是数组元素的类型，`ptr`是指向数组的指针，`size`是数组的大小。
- 数组指针指向的是整个数组，而不是数组中的单个元素。

```c
int arr[5];
int (*ptr)[5]; // 声明一个指向包含5个整数的数组的指针
ptr = &arr; // 将指针指向数组的首地址
```

**指针数组:**

- 指针数组是一个数组，其中的每个元素都是指针。
- 通常声明为`type *ptr[size]`的形式，其中`type`是指针指向的数据类型，`ptr`是指针数组，`size`是数组的大小。
- 指针数组存储了多个指针，每个指针可以指向不同的数据。

```c
int *ptr[5]; // 声明一个包含5个指向整数的指针的数组
```



---------------------------------------------------------------------------------------

**C++**

------------------------------------------------

