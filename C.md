**C**

--------------------------------------------------------------------------

**1.C语言头文件**



**「在头文件中定义定义函数和全局变量」这种认知是原则性的错误！**不管是标准头文件，还是自定义头文件，都只能包**含变量和函数的声明，不能包含定义**，否则在多次引入时会引起重复定义错误。

此外，可能还有初学者会问，main.c 只是引入了 my.h，没有引入 my.c，程序在编译时应该找不到函数定义呀，然而当我们亲自去运行程序的时候，却发现运行结果是正确的，这是怎么回事呢？

 C语言多文件编程涉及到很多细节，需要深入理解编译和链接的原理，本节我们仅做演示，不做更多讲解，感兴趣的读者请自行查阅相关资料。



C语言头文件中只能包含变量和函数的声明的，不能包含定义



C语言头文件可以包括:



- 函数声明

- 变量声明

- 宏定义

- 结构体和枚举类型定义

- 其它头文件

- 变量定义

  ​	extern 变量

  ​    static   变量



**2. .c源文件**



.c 源文件如果要用到某个结构体，则需要包含头文件，头文件一般需要在结构体中定义



**3.不带参数的宏定义**

```c
#ifndef MYMACROS_H
#define MYMACROS_H
```

`MYMACROS_H`这个宏没有具体的值，只是起到一个标记的作用，用于在后续的代码中进行条件编译的判断。



**4.反码，补码问题**

前提: 有符号的整数

正数的反码：仍然是原码

正数补码： 仍然是原码

负数的反码: 除符号位外，每位取反

负数补码: 反码+1



**5.二进制表示**

首位是1是负数

首位是0是正数



**6.计算机中数字都是以补码形式存储的**



**7.补码减法计算原理**

```
补码+补码

十进制为例

15-7

位宽为4

15:0015

-7:1007

-7的反码为9999-7=9992

-7补码为9992+1=9993

0015+9993=10008 舍弃最高位变成了0008
```

*醍醐灌顶的解释*

```
假设现在标准时间为4点整，而有一只表已经到7点了，为了校准时间，可以采用两种方法：一种是将时针退7-4=3格；二是将时针向前拨12-3=9格，这两种方法都可以校准到4点。

摘自《计算机组成原理》p20 第2节

这个例子的意思可以理解为将7变为4，在钟表环境（12进制）下可以表示为7-3和7+9

意即钟表法则中

7-3=7+9

看了这个例子，你大概已经知道能这样做的原因是什么了

根本在于

钟表法则中超过12的数会溢出，重新从0开始计算

准确的说这里的12应该被称为模长，也是补码得以有效的关键，在表示的数值大小被限制时，有了溢出就能将减法变成加法了。

有了这个条件，现在可以总结出一套推论

模长为m时，x-y=x+m-y

你可能会觉得这有什么用？还是得用模长做减法才能得出这个等效加数呀

这就是二进制得天独厚的优势了

m-y可以转变为m-1-y+1

这不是废话吗

别急，在二进制中计算机能表示的数的大小总是以位计算的，也就是说，假如总共有8位，那么模长就是2^8,能表示的是0~2^8-1之间的数。

这时候m-1表示的就是1111 1111，上面的m-1-y+1就是1111 1111 - y +1

而1111 1111-y等效于~y(对y求反)，求一个数的反码在计算机中是很容易实现的，通过触发器互补输出得到

这时x-y=x+~y+1      补码由此实现将减法变为加法

 

总结

补码的意义建立在数值位数确定的情况

补码通过溢出实现将减法转变为加法
```



---------------------------------------------------------------------------------------

**C++**

------------------------------------------------

